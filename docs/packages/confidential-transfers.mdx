---
title: '@sei-js/confidential-transfers'
description: 'Privacy-preserving transactions on Sei blockchain'
---

## Overview

The `@sei-js/confidential-transfers` package provides TypeScript libraries for interacting with Sei's Confidential Transfers module. This enables privacy-preserving transactions where transaction amounts and balances are encrypted, providing enhanced privacy while maintaining the security and transparency of the blockchain.

<CardGroup cols={2}>
  <Card
    title="Privacy Protection"
    icon="shield"
  >
    Encrypt transaction amounts and account balances
  </Card>
  <Card
    title="Zero-Knowledge Proofs"
    icon="key"
  >
    Cryptographic proofs without revealing sensitive data
  </Card>
  <Card
    title="Cross-Platform"
    icon="code"
  >
    Works in both browser and Node.js environments
  </Card>
  <Card
    title="Dual Library Support"
    icon="layer-group"
  >
    Compatible with both Ethers.js and Viem
  </Card>
</CardGroup>

## Installation

<CodeGroup>

```bash npm
npm install @sei-js/confidential-transfers
```

```bash yarn
yarn add @sei-js/confidential-transfers
```

```bash pnpm
pnpm add @sei-js/confidential-transfers
```

</CodeGroup>

## Prerequisites

### Development Setup

<Steps>
  <Step title="Install Dependencies">
    ```bash
    yarn install
    ```
  </Step>
  
  <Step title="Build WASM Module">
    Build the WebAssembly module from Go code:
    ```bash
    yarn build-wasm
    ```
  </Step>
  
  <Step title="Build Package">
    ```bash
    yarn build
    ```
  </Step>
  
  <Step title="Run Tests">
    ```bash
    yarn test
    ```
    Note: Tests require a running Sei chain instance locally.
  </Step>
</Steps>

### Local Chain Setup

For development and testing, you'll need a local Sei chain instance with the Confidential Transfers module enabled.

## Core Concepts

### Confidential Accounts

In the Confidential Transfers module, each account has a unique keypair for each denomination. This keypair is derived from:

1. Appending "ct:" to the denomination
2. Keccak256 hashing the result
3. Signing the hash with the wallet

<Warning>
The signature should never be revealed or stored server-side as it can be used to derive your confidential private keys.
</Warning>

### Balance Types

<AccordionGroup>
  <Accordion title="Available Balance">
    - Ready for spending in confidential transactions
    - Encrypted and stored on-chain
    - Can be partially decrypted for efficiency
  </Accordion>

  <Accordion title="Pending Balance">
    - Recently deposited funds awaiting confirmation
    - Must be "applied" to become available
    - Encrypted until applied
  </Accordion>

  <Accordion title="Decryptable Balance">
    - Portion of available balance that can be quickly decrypted
    - Used for efficiency in balance queries
    - Subset of total available balance
  </Accordion>
</AccordionGroup>

## Ethers.js Integration

### Basic Setup

<CodeGroup>

```typescript Wallet Setup
import { ethers } from 'ethers';

// Connect to local Sei EVM
const provider = new ethers.JsonRpcProvider("http://localhost:8545");
const wallet = ethers.Wallet.createRandom().connect(provider);

console.log('Wallet address:', wallet.address);
```

```typescript Import Functions
import {
  getDenomToSignEthers,
  initializeAccountEthers,
  queryAccountEthers,
  decryptAccountEthers,
  depositToPrivateBalanceEthers,
  applyPendingBalanceEthers,
  transferConfidentialEthers
} from '@sei-js/confidential-transfers';
```

</CodeGroup>

### Step 1: Sign Denomination

Generate the cryptographic signature for a denomination:

<CodeGroup>

```typescript Sign Denomination
const denom = "usei";

// Get the hash to sign
const denomHash = getDenomToSignEthers(denom);

// Sign with wallet (this derives your confidential keypair)
const signedDenom = await wallet.signMessage(denomHash);

console.log('Signed denomination:', signedDenom);
```

```typescript Multiple Denominations
const denoms = ["usei", "uatom", "uosmo"];
const signedDenoms = {};

for (const denom of denoms) {
  const denomHash = getDenomToSignEthers(denom);
  signedDenoms[denom] = await wallet.signMessage(denomHash);
}

console.log('All signed denominations:', signedDenoms);
```

</CodeGroup>

### Step 2: Initialize Account

Create a confidential account on-chain:

<CodeGroup>

```typescript Initialize Account
// Initialize confidential account for usei
await initializeAccountEthers(
  signedDenom,    // Signature from step 1
  wallet.address, // Your wallet address
  denom,          // Denomination
  wallet          // Wallet instance
);

console.log('Confidential account initialized');
```

```typescript Error Handling
try {
  await initializeAccountEthers(signedDenom, wallet.address, denom, wallet);
  console.log('Account initialized successfully');
} catch (error) {
  if (error.message.includes('already exists')) {
    console.log('Account already initialized');
  } else {
    console.error('Initialization failed:', error);
  }
}
```

</CodeGroup>

### Step 3: Query Account Information

Fetch confidential account state:

<CodeGroup>

```typescript Query Account
const account = await queryAccountEthers(
  wallet.address, // Account address
  denom,          // Denomination
  wallet          // Wallet instance
);

console.log('Account info:', {
  address: account.address,
  denom: account.denom,
  encryptedBalance: account.encryptedAvailableBalance,
  pendingBalance: account.encryptedPendingBalance
});
```

```typescript Account Validation
const account = await queryAccountEthers(wallet.address, denom, wallet);

if (!account) {
  throw new Error('Account not found - initialize first');
}

if (!account.encryptedAvailableBalance) {
  console.log('No available balance');
}

if (account.encryptedPendingBalance) {
  console.log('Pending balance detected - apply to make available');
}
```

</CodeGroup>

### Step 4: Decrypt Balances

Decrypt encrypted balance commitments:

<CodeGroup>

```typescript Decrypt Balances
// Decrypt balances (quick decryption)
const decrypted = await decryptAccountEthers(
  signedDenom, // Signature for decryption keys
  account,     // Account object from query
  false        // false = quick decrypt, true = full decrypt
);

console.log('Decrypted balances:', {
  availableBalance: decrypted.availableBalance,
  pendingBalance: decrypted.pendingBalance,
  decryptableBalance: decrypted.decryptableAvailableBalance
});
```

```typescript Full Balance Decryption
// Full decryption (slower but complete)
const fullDecrypted = await decryptAccountEthers(
  signedDenom,
  account,
  true // Full decryption of available balance
);

console.log('Full available balance:', fullDecrypted.availableBalance);
console.log('This may take longer for large balances');
```

</CodeGroup>

### Step 5: Deposit Funds

Deposit public funds into confidential balance:

<CodeGroup>

```typescript Deposit Funds
const depositAmount = 1000000; // 1 SEI (in microSEI)

await depositToPrivateBalanceEthers(
  denom,        // Denomination
  depositAmount, // Amount in native decimals
  wallet        // Wallet instance
);

console.log(`Deposited ${depositAmount / 1000000} SEI to confidential balance`);
```

```typescript Deposit with Validation
const depositAmount = 5000000; // 5 SEI

// Check public balance first
const publicBalance = await wallet.provider.getBalance(wallet.address);
const requiredAmount = ethers.parseEther((depositAmount / 1000000).toString());

if (publicBalance < requiredAmount) {
  throw new Error('Insufficient public balance for deposit');
}

await depositToPrivateBalanceEthers(denom, depositAmount, wallet);
console.log('Deposit successful');
```

</CodeGroup>

### Step 6: Apply Pending Balance

Move pending deposits to available balance:

<CodeGroup>

```typescript Apply Pending
await applyPendingBalanceEthers(
  signedDenom, // Signature for account access
  wallet       // Wallet instance
);

console.log('Pending balance applied to available balance');
```

```typescript Apply with Balance Check
// Check pending balance before applying
const accountBefore = await queryAccountEthers(wallet.address, denom, wallet);
const decryptedBefore = await decryptAccountEthers(signedDenom, accountBefore, false);

if (decryptedBefore.pendingBalance > 0) {
  await applyPendingBalanceEthers(signedDenom, wallet);
  
  // Verify application
  const accountAfter = await queryAccountEthers(wallet.address, denom, wallet);
  const decryptedAfter = await decryptAccountEthers(signedDenom, accountAfter, false);
  
  console.log('Balance applied:', {
    before: decryptedBefore.availableBalance,
    after: decryptedAfter.availableBalance,
    applied: decryptedBefore.pendingBalance
  });
} else {
  console.log('No pending balance to apply');
}
```

</CodeGroup>

### Step 7: Confidential Transfers

Send confidential transactions between accounts:

<CodeGroup>

```typescript Confidential Transfer
const recipientAddress = "0x..."; // Recipient's address
const transferAmount = 500000;     // 0.5 SEI

await transferConfidentialEthers(
  signedDenom,      // Your signed denomination
  recipientAddress, // Recipient address
  transferAmount,   // Amount to transfer
  wallet           // Your wallet
);

console.log(`Transferred ${transferAmount / 1000000} SEI confidentially`);
```

```typescript Transfer with Validation
const recipientAddress = "0x742d35Cc6634C0532925a3b8D0Ac6e1a4b5c4e1";
const transferAmount = 2000000; // 2 SEI

// Check available balance
const account = await queryAccountEthers(wallet.address, denom, wallet);
const decrypted = await decryptAccountEthers(signedDenom, account, false);

if (decrypted.availableBalance < transferAmount) {
  throw new Error('Insufficient confidential balance');
}

// Ensure recipient has initialized account
try {
  await queryAccountEthers(recipientAddress, denom, wallet);
} catch (error) {
  throw new Error('Recipient must initialize confidential account first');
}

await transferConfidentialEthers(signedDenom, recipientAddress, transferAmount, wallet);
console.log('Confidential transfer completed');
```

</CodeGroup>

## Viem Integration

### Basic Setup

<CodeGroup>

```typescript Viem Setup
import { createWalletClient, createPublicClient, http } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { seiTestnet } from 'viem/chains';

// Create account from private key
const account = privateKeyToAccount('0x...');

// Create clients
const publicClient = createPublicClient({
  chain: seiTestnet,
  transport: http('http://localhost:8545')
});

const walletClient = createWalletClient({
  account,
  chain: seiTestnet,
  transport: http('http://localhost:8545')
});
```

```typescript Viem Functions Import
import {
  getDenomToSignViem,
  initializeAccountViem,
  queryAccountViem,
  decryptAccountViem,
  depositToPrivateBalanceViem,
  applyPendingBalanceViem,
  transferConfidentialViem
} from '@sei-js/confidential-transfers';
```

</CodeGroup>

### Viem Workflow

<CodeGroup>

```typescript Complete Viem Example
// 1. Sign denomination
const denom = "usei";
const denomHash = getDenomToSignViem(denom);
const signedDenom = await walletClient.signMessage({
  account,
  message: denomHash
});

// 2. Initialize account
await initializeAccountViem(
  signedDenom,
  account.address,
  denom,
  walletClient
);

// 3. Deposit funds
await depositToPrivateBalanceViem(
  denom,
  1000000, // 1 SEI
  walletClient
);

// 4. Apply pending balance
await applyPendingBalanceViem(signedDenom, walletClient);

// 5. Query and decrypt
const account = await queryAccountViem(account.address, denom, publicClient);
const decrypted = await decryptAccountViem(signedDenom, account, false);

console.log('Confidential balance:', decrypted.availableBalance);
```

</CodeGroup>

## Advanced Usage

### Multi-Denomination Management

<CodeGroup>

```typescript Multi-Denom Manager
class ConfidentialWalletManager {
  private wallet: ethers.Wallet;
  private signedDenoms: Map<string, string> = new Map();
  
  constructor(wallet: ethers.Wallet) {
    this.wallet = wallet;
  }
  
  async initializeDenom(denom: string) {
    const denomHash = getDenomToSignEthers(denom);
    const signedDenom = await this.wallet.signMessage(denomHash);
    this.signedDenoms.set(denom, signedDenom);
    
    await initializeAccountEthers(
      signedDenom,
      this.wallet.address,
      denom,
      this.wallet
    );
  }
  
  async getBalance(denom: string) {
    const signedDenom = this.signedDenoms.get(denom);
    if (!signedDenom) throw new Error(`Denomination ${denom} not initialized`);
    
    const account = await queryAccountEthers(this.wallet.address, denom, this.wallet);
    const decrypted = await decryptAccountEthers(signedDenom, account, false);
    
    return {
      available: decrypted.availableBalance,
      pending: decrypted.pendingBalance
    };
  }
  
  async transfer(denom: string, to: string, amount: number) {
    const signedDenom = this.signedDenoms.get(denom);
    if (!signedDenom) throw new Error(`Denomination ${denom} not initialized`);
    
    await transferConfidentialEthers(signedDenom, to, amount, this.wallet);
  }
}

// Usage
const manager = new ConfidentialWalletManager(wallet);
await manager.initializeDenom("usei");
await manager.initializeDenom("uatom");

const seiBalance = await manager.getBalance("usei");
console.log('SEI balance:', seiBalance);
```

</CodeGroup>

### Batch Operations

<CodeGroup>

```typescript Batch Transfers
async function batchConfidentialTransfers(
  transfers: Array<{to: string, amount: number, denom: string}>,
  wallet: ethers.Wallet,
  signedDenoms: Map<string, string>
) {
  const results = [];
  
  for (const transfer of transfers) {
    const signedDenom = signedDenoms.get(transfer.denom);
    if (!signedDenom) {
      throw new Error(`No signed denomination for ${transfer.denom}`);
    }
    
    try {
      await transferConfidentialEthers(
        signedDenom,
        transfer.to,
        transfer.amount,
        wallet
      );
      
      results.push({
        ...transfer,
        status: 'success'
      });
    } catch (error) {
      results.push({
        ...transfer,
        status: 'failed',
        error: error.message
      });
    }
  }
  
  return results;
}

// Usage
const transfers = [
  { to: "0x123...", amount: 1000000, denom: "usei" },
  { to: "0x456...", amount: 500000, denom: "usei" },
  { to: "0x789...", amount: 2000000, denom: "uatom" }
];

const results = await batchConfidentialTransfers(transfers, wallet, signedDenoms);
console.log('Batch transfer results:', results);
```

</CodeGroup>

### Balance Monitoring

<CodeGroup>

```typescript Balance Monitor
class ConfidentialBalanceMonitor {
  private wallet: ethers.Wallet;
  private signedDenoms: Map<string, string>;
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  
  constructor(wallet: ethers.Wallet, signedDenoms: Map<string, string>) {
    this.wallet = wallet;
    this.signedDenoms = signedDenoms;
  }
  
  async startMonitoring(denom: string, intervalMs: number = 30000) {
    const interval = setInterval(async () => {
      try {
        await this.checkAndApplyPending(denom);
      } catch (error) {
        console.error(`Monitoring error for ${denom}:`, error);
      }
    }, intervalMs);
    
    this.intervals.set(denom, interval);
    console.log(`Started monitoring ${denom} every ${intervalMs}ms`);
  }
  
  stopMonitoring(denom: string) {
    const interval = this.intervals.get(denom);
    if (interval) {
      clearInterval(interval);
      this.intervals.delete(denom);
      console.log(`Stopped monitoring ${denom}`);
    }
  }
  
  private async checkAndApplyPending(denom: string) {
    const signedDenom = this.signedDenoms.get(denom);
    if (!signedDenom) return;
    
    const account = await queryAccountEthers(this.wallet.address, denom, this.wallet);
    const decrypted = await decryptAccountEthers(signedDenom, account, false);
    
    if (decrypted.pendingBalance > 0) {
      console.log(`Applying pending balance: ${decrypted.pendingBalance} ${denom}`);
      await applyPendingBalanceEthers(signedDenom, this.wallet);
    }
  }
  
  stopAll() {
    for (const denom of this.intervals.keys()) {
      this.stopMonitoring(denom);
    }
  }
}

// Usage
const monitor = new ConfidentialBalanceMonitor(wallet, signedDenoms);
await monitor.startMonitoring("usei", 30000); // Check every 30 seconds
```

</CodeGroup>

## Security Best Practices

<AccordionGroup>
  <Accordion title="Key Management">
    - Never store signed denominations in plaintext
    - Use secure key derivation for multiple accounts
    - Implement proper key rotation strategies
    - Store sensitive data in secure environments only
  </Accordion>

  <Accordion title="Transaction Privacy">
    - Verify recipient accounts are initialized before transfers
    - Use appropriate amounts to maintain privacy
    - Consider transaction timing and patterns
    - Implement proper error handling to avoid information leakage
  </Accordion>

  <Accordion title="Balance Management">
    - Regularly apply pending balances
    - Monitor for unexpected balance changes
    - Implement balance validation before transactions
    - Use partial decryption when full balance isn't needed
  </Accordion>

  <Accordion title="Development">
    - Test thoroughly on local/testnet before mainnet
    - Implement comprehensive error handling
    - Use proper logging without exposing sensitive data
    - Validate all inputs and outputs
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Account Initialization">
    **Problem**: Account initialization fails
    
    **Solutions**:
    - Ensure wallet has sufficient balance for gas fees
    - Verify the denomination is supported
    - Check if account already exists
    - Confirm local chain is running with CT module
  </Accordion>

  <Accordion title="Decryption Issues">
    **Problem**: Balance decryption returns incorrect values
    
    **Solutions**:
    - Verify the signed denomination matches the original signature
    - Ensure account is properly initialized
    - Check if pending balances need to be applied
    - Try full decryption if partial fails
  </Accordion>

  <Accordion title="Transfer Failures">
    **Problem**: Confidential transfers fail
    
    **Solutions**:
    - Verify recipient account is initialized
    - Check available balance is sufficient
    - Ensure proper denomination signatures
    - Validate transfer amount is positive
  </Accordion>

  <Accordion title="WASM Issues">
    **Problem**: WebAssembly module fails to load
    
    **Solutions**:
    - Rebuild WASM module with `yarn build-wasm`
    - Check browser WASM support
    - Verify file paths and imports
    - Ensure proper build configuration
  </Accordion>
</AccordionGroup>

## Performance Optimization

<AccordionGroup>
  <Accordion title="Decryption Optimization">
    - Use partial decryption (`false` parameter) when possible
    - Cache decrypted balances for short periods
    - Implement progressive decryption for large balances
    - Consider background decryption for better UX
  </Accordion>

  <Accordion title="Transaction Batching">
    - Group multiple operations when possible
    - Use appropriate gas limits for batch operations
    - Implement retry mechanisms for failed transactions
    - Consider transaction ordering for efficiency
  </Accordion>

  <Accordion title="Memory Management">
    - Clear sensitive data from memory after use
    - Implement proper cleanup for WASM modules
    - Use appropriate data structures for large datasets
    - Monitor memory usage in long-running applications
  </Accordion>
</AccordionGroup>

## Examples

<CardGroup cols={2}>
  <Card
    title="Privacy Wallet"
    icon="wallet"
    href="https://github.com/sei-protocol/sei-js/tree/main/examples/confidential-wallet"
  >
    Complete privacy-focused wallet application
  </Card>
  <Card
    title="Anonymous Payments"
    icon="money-bill"
    href="https://github.com/sei-protocol/sei-js/tree/main/examples/anonymous-payments"
  >
    Anonymous payment system using confidential transfers
  </Card>
  <Card
    title="Privacy DEX"
    icon="exchange-alt"
    href="https://github.com/sei-protocol/sei-js/tree/main/examples/privacy-dex"
  >
    Decentralized exchange with confidential trading
  </Card>
  <Card
    title="Confidential DeFi"
    icon="chart-line"
    href="https://github.com/sei-protocol/sei-js/tree/main/examples/confidential-defi"
  >
    DeFi protocols with privacy features
  </Card>
</CardGroup>

## API Reference

For complete API documentation, see the [TypeDoc reference](https://sei-protocol.github.io/sei-js/modules/confidential_transfers.html).
