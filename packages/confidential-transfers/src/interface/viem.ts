import { MsgApplyPendingBalance, MsgTransfer, MsgWithdraw } from "@sei-js/cosmos/dist/types/encoding/confidentialtransfers"
import { Encoder } from "@sei-js/cosmos/encoding"
import { CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI, CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS } from "@sei-js/evm"
import { bytesToHex, hexToBytes, keccak256, parseEther, PublicClient, toBytes, isAddress } from "viem"
import { ConfidentialTransfersWrapper } from "../payload/confidentialApi"
import { DecryptedAccount, DecryptedPendingBalances } from "./types"

export interface CtAccountResponse {
    publicKey: `0x${string}`, // serialized public key
    pendingBalanceLo: `0x${string}`,  // lo bits of the pending balance
    pendingBalanceHi: `0x${string}`, // hi bits of the pending balance
    pendingBalanceCreditCounter: number,
    availableBalance: `0x${string}` // elgamal encoded balance
    decryptableAvailableBalance: string // aes encoded balance
}

/**
 * Queries the on-chain confidential account state for a given address and denom.
 *
 * @param client - A Viem PublicClient instance.
 * @param address - The 0x account address to query.
 * @param denom - The denom of the confidential account.
 * @returns A CtAccountResponse object, or null if the account is not initialized.
 */
export async function queryAccountViem(
    client: PublicClient,
    address: string | `0x${string}`,
    denom: string,
  ): Promise<CtAccountResponse | null> {
    // Sanity checks
    if (!isAddress(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    let account;
  
    try {
      account = await client.readContract({
        abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        address: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        functionName: "account",
        args: [address, denom]
      });

      return account as CtAccountResponse
    } catch (error: any) {
      console.error("Error fetching account:", error.message);
      return null;
    }
}

/**
 * Decrypts the pending balance ciphertexts from a CtAccount.
 *
 * @param signedDenom - Signature over the hashed denom generated by getDenomToSignViem.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The low, high, and combined pending balances.
 */
export async function decryptPendingBalancesViem(signedDenom: `0x${string}`, ctAccount: CtAccountResponse): Promise<DecryptedPendingBalances> {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();
    const signedDenomArray = hexToBytes(signedDenom)
    
    const pendingBalanceLo = api.decryptCiphertext(signedDenomArray, hexToBytes(ctAccount.pendingBalanceLo))
    const pendingBalanceHi = api.decryptCiphertext(signedDenomArray, hexToBytes(ctAccount.pendingBalanceHi))
    return {
        pendingBalanceLo: pendingBalanceLo,
        pendingBalanceHi: pendingBalanceHi,
        totalPendingBalance: pendingBalanceLo + (pendingBalanceHi << BigInt(16))
    }
}

/**
 * Decrypts the AES-encrypted decryptable available balance.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The decrypted available balance.
 */
export async function decryptDecryptableAvailableBalanceViem(signedDenom: `0x${string}`, ctAccount: CtAccountResponse): Promise<bigint> {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();
    const signedDenomArray = hexToBytes(signedDenom)
    
    const decryptableAvailableBalance = api.decryptAesCiphertext(signedDenomArray, ctAccount.decryptableAvailableBalance)
    return decryptableAvailableBalance
}

/**
 * Fully decrypts the committed available balance (slow path).
 * Only needed if decryptable balance is insufficient or untrusted.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The decrypted available balance.
 */
export async function decryptAvailableBalanceViem(signedDenom: `0x${string}`, ctAccount: CtAccountResponse): Promise<bigint> {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();
    const signedDenomArray = hexToBytes(signedDenom)
    
    const availableBalance = api.decryptCiphertext(signedDenomArray, hexToBytes(ctAccount.availableBalance))
    return availableBalance
}

/**
 * Fully decrypts all encrypted components of a confidential account.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @param decryptFullAvailableBalance - Whether to decrypt the available balance (slow).
 * @returns A DecryptedAccount object.
 */
export async function decryptAccountViem(signedDenom: `0x${string}`, ctAccount: CtAccountResponse, decryptFullAvailableBalance: boolean): Promise<DecryptedAccount> {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();
    const decryptedPendingBalances = await decryptPendingBalancesViem(signedDenom, ctAccount)
    const decryptedDecryptableAvailableBalance = await decryptDecryptableAvailableBalanceViem(signedDenom, ctAccount)
    const data = {
        publicKey: ctAccount.publicKey,
        pendingBalanceLo: decryptedPendingBalances.pendingBalanceLo,
        pendingBalanceHi: decryptedPendingBalances.pendingBalanceHi,
        totalPendingBalance: decryptedPendingBalances.totalPendingBalance,
        pendingBalanceCreditCounter: ctAccount.pendingBalanceCreditCounter,
        availableBalance: "Not Decrypted",
        decryptableAvailableBalance: decryptedDecryptableAvailableBalance
    }

    if (decryptFullAvailableBalance) {
        const decryptedAvailableBalance = await decryptAvailableBalanceViem(signedDenom, ctAccount)
        data.availableBalance = decryptedAvailableBalance.toString()
    }

    return data
}

/**
 * Generates calldata for depositing into a confidential account.
 *
 * @param address - The address initiating the deposit.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to deposit.
 * @returns A Viem-compatible calldata params object.
 */
export async function getInitializeAccountViemArgs(signedDenom: `0x${string}`, address: string | `0x${string}`, denom: string) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!isAddress(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    const api = new ConfidentialTransfersWrapper();
    await api.initialize();

    const signedDenomArray = hexToBytes(signedDenom)
    const initializePayload = api.createInitialize(
        signedDenomArray,
        address,
        denom,
    );

    let encodedPendingBalanceLo = Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.pending_balance_lo!).finish()
    let encodedPendingBalanceHi = Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.pending_balance_hi!).finish()
    let encodedAvailableBalance = Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.available_balance!).finish()
    const encodedProofs = Encoder.confidentialtransfers.InitializeAccountMsgProofs.encode(initializePayload.proofs!).finish()

    const encodedPendingBalanceLoHex = bytesToHex(encodedPendingBalanceLo)
    const encodedPendingBalanceHiHex = bytesToHex(encodedPendingBalanceHi)
    const encodedAvailableBalanceHex = bytesToHex(encodedAvailableBalance)
    const publicKeyHex = bytesToHex(initializePayload.public_key)
    const encodedProofsHex = bytesToHex(encodedProofs)

    const params = {
        account: initializePayload.from_address,
        address:CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "initializeAccount",
        args: [
            initializePayload.from_address,
            initializePayload.denom,
            publicKeyHex,
            initializePayload.decryptable_balance,
            encodedPendingBalanceLoHex,
            encodedPendingBalanceHiHex,
            encodedAvailableBalanceHex,
            encodedProofsHex
        ],
        value: parseEther('0')
    }
    return params
}

/**
 * Generates calldata for depositing into a confidential account.
 *
 * @param address - The 0x address initiating the deposit.
 * @param denom - The denom of the confidential account.
 * @param amount - Amount to deposit in base units (e.g., 1 SEI = 1_000_000).
 * @returns A Viem-compatible calldata params object.
 */
export function getDepositToPrivateBalanceViemArgs(address: string | `0x${string}` | undefined, denom: string, amount: bigint) {
    // Sanity checks
    if (address && !isAddress(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= BigInt(0)) {
        throw new Error('Amount must be a positive number');
    }
    const params = {
        account: address,
        address: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "deposit",
        args: [denom, amount]
    }
    
    return params
}

/**
 * Generates calldata for applying pending balances to a confidential account.
 *
 * @param address - The 0x address of the account.
 * @param denom - The denom of the confidential account.
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if the account is uninitialized.
 */
export async function getApplyPendingBalancesViemArgs(address: string, denom: string, client: PublicClient, signedDenom: `0x${string}`) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!isAddress(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();

    const signedDenomArray = hexToBytes(signedDenom)
    const ctAccount = await queryAccountViem(client, address, denom)
    if (ctAccount === null) {
      return null
    }

    const applyPendingBalancesPayload = api.createApplyPendingBalance(
        signedDenomArray,
        address,
        denom,
        ctAccount.pendingBalanceCreditCounter,
        ctAccount.decryptableAvailableBalance,
        hexToBytes(ctAccount.availableBalance),
        hexToBytes(ctAccount.pendingBalanceLo),
        hexToBytes(ctAccount.pendingBalanceHi)
    );

    return getApplyPendingBalancesArgs(applyPendingBalancesPayload)
}


function getApplyPendingBalancesArgs(applyPayload: MsgApplyPendingBalance) {
    let encodedAvailableBalance = Encoder.confidentialtransfers.Ciphertext.encode(applyPayload.current_available_balance!).finish()
    const encodedAvailableBalanceHex = bytesToHex(encodedAvailableBalance)

    const params = {
        account: applyPayload.address,
        address:CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "applyPendingBalance",
        args: [
            applyPayload.denom,
            applyPayload.new_decryptable_available_balance,
            applyPayload.current_pending_balance_counter,
            encodedAvailableBalanceHex,
        ],
        value: parseEther('0')
    }
    return params
}

/**
 * Generates calldata for withdrawing from a confidential account.
 *
 * @param address - The address of the account.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to withdraw in base units (e.g., 1 SEI = 1_000_000).
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if the account is uninitialized.
 */
export async function getWithdrawFromPrivateBalanceViemArgs(address: string, denom: string, amount: number, client: PublicClient, signedDenom: `0x${string}`) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!isAddress(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= 0) {
        throw new Error('Amount must be a positive number');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();

    const signedDenomArray = hexToBytes(signedDenom)
    const ctAccount = await queryAccountViem(client, address, denom)
    if (ctAccount === null) {
        return null
    }
    const withdrawPayload = api.createWithdraw(
        signedDenomArray,
        amount,
        address,
        denom,
        ctAccount.decryptableAvailableBalance,
        hexToBytes(ctAccount.availableBalance),
    );

    return getWithdrawArgs(withdrawPayload)
}

function getWithdrawArgs(withdrawPayload: MsgWithdraw) {
  let encodedRemainingBalanceCommitment = Encoder.confidentialtransfers.Ciphertext.encode(withdrawPayload.remaining_balance_commitment!).finish()
  let encodedProofs = Encoder.confidentialtransfers.WithdrawMsgProofs.encode(withdrawPayload.proofs!).finish()
  const encodedRemainingBalanceCommitmentHex = bytesToHex(encodedRemainingBalanceCommitment)
  const encodedProofsHex = bytesToHex(encodedProofs)

  const params = {
      account: withdrawPayload.from_address,
      address:CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
      abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
      functionName: "withdraw",
      args: [
        withdrawPayload.denom,
          withdrawPayload.amount,
          withdrawPayload.decryptable_balance,
          encodedRemainingBalanceCommitmentHex,
          encodedProofsHex,
      ],
      value: parseEther('0')
  }
  return params
}

/**
 * Generates calldata for transferring confidential balance to another account.
 *
 * @param senderAddress - The sender's address.
 * @param recipientAddress - The recipient's address.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to transfer.
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if either account is uninitialized.
 */
export async function getConfidentialTransferViemArgs(senderAddress: string, recipientAddress: string, denom: string, amount: number, client: PublicClient, signedDenom: `0x${string}`) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!isAddress(senderAddress)) {
        throw new Error('Invalid sender address format');
    }
    if (!isAddress(recipientAddress)) {
        throw new Error('Invalid recipient address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= 0) {
        throw new Error('Amount must be a positive number');
    }
    const api = new ConfidentialTransfersWrapper()
    await api.initialize();
    
    const signedDenomArray = hexToBytes(signedDenom)

    const senderAccount = await queryAccountViem(client, senderAddress, denom)
    if (senderAccount === null) {
        return null
    }

    const recipientAccount = await queryAccountViem(client, recipientAddress, denom)
    if (recipientAccount === null) {
        return null
    }

    const transferPayload = api.createTransfer(
        signedDenomArray,
        amount,
        senderAddress,
        recipientAddress,
        denom,
        senderAccount.decryptableAvailableBalance,
        hexToBytes(senderAccount.availableBalance),
        hexToBytes(recipientAccount.publicKey)
    );
  
    return getTransferArgs(transferPayload)
}
  
function getTransferArgs(transferPayload: MsgTransfer) {
    let encodedFromAmountLo = Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.from_amount_lo!).finish()
    let encodedFromAmountHi = Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.from_amount_hi!).finish()
    let encodedToAmountLo = Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.to_amount_lo!).finish()
    let encodedToAmountHi = Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.to_amount_hi!).finish()
    let encodedRemainingBalance = Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.remaining_balance!).finish()
    let encodedProofs = Encoder.confidentialtransfers.TransferMsgProofs.encode(transferPayload.proofs!).finish()

    const encodedFromAmountLoHex = bytesToHex(encodedFromAmountLo)
    const encodedFromAmountHiHex = bytesToHex(encodedFromAmountHi)
    const encodedToAmountLoHex = bytesToHex(encodedToAmountLo)
    const encodedToAmountHiHex = bytesToHex(encodedToAmountHi)
    const encodedRemainingBalanceHex = bytesToHex(encodedRemainingBalance)
    const encodedProofsHex = bytesToHex(encodedProofs)
  
    const params = {
        account: transferPayload.from_address,
        address:CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "transfer",
        args: [
            transferPayload.to_address,
            transferPayload.denom,
            encodedFromAmountLoHex,
            encodedFromAmountHiHex,
            encodedToAmountLoHex,
            encodedToAmountHiHex,
            encodedRemainingBalanceHex,
            transferPayload.decryptable_balance,
            encodedProofsHex,
        ],
        value: parseEther('0')
    }
    return params
}

/**
 * Hashes a denom into the format expected by the signing process ("ct:" + denom).
 * Signing this hash generates a secret from which the confidential balances' private keypair can be derived.
 *
 * @param denom - The denom string (e.g., "usei").
 * @returns A keccak256 hash of the prefixed denom, ready to sign.
 */
export function getDenomToSignViem(denom: string) {
    const appendedDenom = "ct:" + denom
    const result = keccak256(toBytes(appendedDenom))
    return result
}