// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: cosmos/bank/v1beta1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../base/query/v1beta1/pagination";
import { Coin } from "../../base/v1beta1/coin";
import { Metadata, Params } from "./bank";

export const protobufPackage = "cosmos.bank.v1beta1";

/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
	/** address is the address to query balances for. */
	address: string;
	/** denom is the coin denom to query balances for. */
	denom: string;
}

/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
	/** balance is the balance of the coin. */
	balance?: Coin | undefined;
}

/** QueryBalanceRequest is the request type for the Query/AllBalances RPC method. */
export interface QueryAllBalancesRequest {
	/** address is the address to query balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest | undefined;
}

/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface QueryAllBalancesResponse {
	/** balances is the balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse | undefined;
}

/**
 * QuerySpendableBalancesRequest defines the gRPC request structure for querying
 * an account's spendable balances.
 */
export interface QuerySpendableBalancesRequest {
	/** address is the address to query spendable balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest | undefined;
}

/**
 * QuerySpendableBalancesResponse defines the gRPC response structure for querying
 * an account's spendable balances.
 */
export interface QuerySpendableBalancesResponse {
	/** balances is the spendable balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse | undefined;
}

/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
 * method.
 */
export interface QueryTotalSupplyRequest {
	/**
	 * pagination defines an optional pagination for the request.
	 *
	 * Since: cosmos-sdk 0.43
	 */
	pagination?: PageRequest | undefined;
}

/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface QueryTotalSupplyResponse {
	/** supply is the supply of the coins */
	supply: Coin[];
	/**
	 * pagination defines the pagination in the response.
	 *
	 * Since: cosmos-sdk 0.43
	 */
	pagination?: PageResponse | undefined;
}

/** QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfRequest {
	/** denom is the coin denom to query balances for. */
	denom: string;
}

/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfResponse {
	/** amount is the supply of the coin. */
	amount?: Coin | undefined;
}

/** QueryParamsRequest defines the request type for querying x/bank parameters. */
export interface QueryParamsRequest {}

/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface QueryParamsResponse {
	params?: Params | undefined;
}

/** QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method. */
export interface QueryDenomsMetadataRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest | undefined;
}

/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface QueryDenomsMetadataResponse {
	/** metadata provides the client information for all the registered tokens. */
	metadatas: Metadata[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse | undefined;
}

/** QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method. */
export interface QueryDenomMetadataRequest {
	/** denom is the coin denom to query the metadata for. */
	denom: string;
}

/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface QueryDenomMetadataResponse {
	/** metadata describes and provides all the client information for the requested token. */
	metadata?: Metadata | undefined;
}

function createBaseQueryBalanceRequest(): QueryBalanceRequest {
	return { address: "", denom: "" };
}

export const QueryBalanceRequest: MessageFns<QueryBalanceRequest, "cosmos.bank.v1beta1.QueryBalanceRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryBalanceRequest" as const,

	encode(message: QueryBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.address !== "") {
			writer.uint32(10).string(message.address);
		}
		if (message.denom !== "") {
			writer.uint32(18).string(message.denom);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryBalanceRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.address = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.denom = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryBalanceRequest {
		return {
			address: isSet(object.address) ? globalThis.String(object.address) : "",
			denom: isSet(object.denom) ? globalThis.String(object.denom) : ""
		};
	},

	toJSON(message: QueryBalanceRequest): unknown {
		const obj: any = {};
		if (message.address !== "") {
			obj.address = message.address;
		}
		if (message.denom !== "") {
			obj.denom = message.denom;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(base?: I): QueryBalanceRequest {
		return QueryBalanceRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryBalanceRequest>, I>>(object: I): QueryBalanceRequest {
		const message = createBaseQueryBalanceRequest();
		message.address = object.address ?? "";
		message.denom = object.denom ?? "";
		return message;
	}
};

function createBaseQueryBalanceResponse(): QueryBalanceResponse {
	return { balance: undefined };
}

export const QueryBalanceResponse: MessageFns<QueryBalanceResponse, "cosmos.bank.v1beta1.QueryBalanceResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryBalanceResponse" as const,

	encode(message: QueryBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.balance !== undefined) {
			Coin.encode(message.balance, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryBalanceResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.balance = Coin.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryBalanceResponse {
		return { balance: isSet(object.balance) ? Coin.fromJSON(object.balance) : undefined };
	},

	toJSON(message: QueryBalanceResponse): unknown {
		const obj: any = {};
		if (message.balance !== undefined) {
			obj.balance = Coin.toJSON(message.balance);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(base?: I): QueryBalanceResponse {
		return QueryBalanceResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryBalanceResponse>, I>>(object: I): QueryBalanceResponse {
		const message = createBaseQueryBalanceResponse();
		message.balance = object.balance !== undefined && object.balance !== null ? Coin.fromPartial(object.balance) : undefined;
		return message;
	}
};

function createBaseQueryAllBalancesRequest(): QueryAllBalancesRequest {
	return { address: "", pagination: undefined };
}

export const QueryAllBalancesRequest: MessageFns<QueryAllBalancesRequest, "cosmos.bank.v1beta1.QueryAllBalancesRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryAllBalancesRequest" as const,

	encode(message: QueryAllBalancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.address !== "") {
			writer.uint32(10).string(message.address);
		}
		if (message.pagination !== undefined) {
			PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryAllBalancesRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryAllBalancesRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.address = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageRequest.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryAllBalancesRequest {
		return {
			address: isSet(object.address) ? globalThis.String(object.address) : "",
			pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QueryAllBalancesRequest): unknown {
		const obj: any = {};
		if (message.address !== "") {
			obj.address = message.address;
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageRequest.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryAllBalancesRequest>, I>>(base?: I): QueryAllBalancesRequest {
		return QueryAllBalancesRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryAllBalancesRequest>, I>>(object: I): QueryAllBalancesRequest {
		const message = createBaseQueryAllBalancesRequest();
		message.address = object.address ?? "";
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQueryAllBalancesResponse(): QueryAllBalancesResponse {
	return { balances: [], pagination: undefined };
}

export const QueryAllBalancesResponse: MessageFns<QueryAllBalancesResponse, "cosmos.bank.v1beta1.QueryAllBalancesResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryAllBalancesResponse" as const,

	encode(message: QueryAllBalancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.balances) {
			Coin.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.pagination !== undefined) {
			PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryAllBalancesResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryAllBalancesResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.balances.push(Coin.decode(reader, reader.uint32()));
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageResponse.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryAllBalancesResponse {
		return {
			balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Coin.fromJSON(e)) : [],
			pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QueryAllBalancesResponse): unknown {
		const obj: any = {};
		if (message.balances?.length) {
			obj.balances = message.balances.map((e) => Coin.toJSON(e));
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageResponse.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryAllBalancesResponse>, I>>(base?: I): QueryAllBalancesResponse {
		return QueryAllBalancesResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryAllBalancesResponse>, I>>(object: I): QueryAllBalancesResponse {
		const message = createBaseQueryAllBalancesResponse();
		message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQuerySpendableBalancesRequest(): QuerySpendableBalancesRequest {
	return { address: "", pagination: undefined };
}

export const QuerySpendableBalancesRequest: MessageFns<QuerySpendableBalancesRequest, "cosmos.bank.v1beta1.QuerySpendableBalancesRequest"> = {
	$type: "cosmos.bank.v1beta1.QuerySpendableBalancesRequest" as const,

	encode(message: QuerySpendableBalancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.address !== "") {
			writer.uint32(10).string(message.address);
		}
		if (message.pagination !== undefined) {
			PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QuerySpendableBalancesRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQuerySpendableBalancesRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.address = reader.string();
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageRequest.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QuerySpendableBalancesRequest {
		return {
			address: isSet(object.address) ? globalThis.String(object.address) : "",
			pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QuerySpendableBalancesRequest): unknown {
		const obj: any = {};
		if (message.address !== "") {
			obj.address = message.address;
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageRequest.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QuerySpendableBalancesRequest>, I>>(base?: I): QuerySpendableBalancesRequest {
		return QuerySpendableBalancesRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QuerySpendableBalancesRequest>, I>>(object: I): QuerySpendableBalancesRequest {
		const message = createBaseQuerySpendableBalancesRequest();
		message.address = object.address ?? "";
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQuerySpendableBalancesResponse(): QuerySpendableBalancesResponse {
	return { balances: [], pagination: undefined };
}

export const QuerySpendableBalancesResponse: MessageFns<QuerySpendableBalancesResponse, "cosmos.bank.v1beta1.QuerySpendableBalancesResponse"> = {
	$type: "cosmos.bank.v1beta1.QuerySpendableBalancesResponse" as const,

	encode(message: QuerySpendableBalancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.balances) {
			Coin.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.pagination !== undefined) {
			PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QuerySpendableBalancesResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQuerySpendableBalancesResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.balances.push(Coin.decode(reader, reader.uint32()));
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageResponse.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QuerySpendableBalancesResponse {
		return {
			balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Coin.fromJSON(e)) : [],
			pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QuerySpendableBalancesResponse): unknown {
		const obj: any = {};
		if (message.balances?.length) {
			obj.balances = message.balances.map((e) => Coin.toJSON(e));
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageResponse.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QuerySpendableBalancesResponse>, I>>(base?: I): QuerySpendableBalancesResponse {
		return QuerySpendableBalancesResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QuerySpendableBalancesResponse>, I>>(object: I): QuerySpendableBalancesResponse {
		const message = createBaseQuerySpendableBalancesResponse();
		message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQueryTotalSupplyRequest(): QueryTotalSupplyRequest {
	return { pagination: undefined };
}

export const QueryTotalSupplyRequest: MessageFns<QueryTotalSupplyRequest, "cosmos.bank.v1beta1.QueryTotalSupplyRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryTotalSupplyRequest" as const,

	encode(message: QueryTotalSupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.pagination !== undefined) {
			PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryTotalSupplyRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pagination = PageRequest.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryTotalSupplyRequest {
		return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
	},

	toJSON(message: QueryTotalSupplyRequest): unknown {
		const obj: any = {};
		if (message.pagination !== undefined) {
			obj.pagination = PageRequest.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(base?: I): QueryTotalSupplyRequest {
		return QueryTotalSupplyRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(object: I): QueryTotalSupplyRequest {
		const message = createBaseQueryTotalSupplyRequest();
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQueryTotalSupplyResponse(): QueryTotalSupplyResponse {
	return { supply: [], pagination: undefined };
}

export const QueryTotalSupplyResponse: MessageFns<QueryTotalSupplyResponse, "cosmos.bank.v1beta1.QueryTotalSupplyResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryTotalSupplyResponse" as const,

	encode(message: QueryTotalSupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.supply) {
			Coin.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.pagination !== undefined) {
			PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryTotalSupplyResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.supply.push(Coin.decode(reader, reader.uint32()));
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageResponse.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryTotalSupplyResponse {
		return {
			supply: globalThis.Array.isArray(object?.supply) ? object.supply.map((e: any) => Coin.fromJSON(e)) : [],
			pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QueryTotalSupplyResponse): unknown {
		const obj: any = {};
		if (message.supply?.length) {
			obj.supply = message.supply.map((e) => Coin.toJSON(e));
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageResponse.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(base?: I): QueryTotalSupplyResponse {
		return QueryTotalSupplyResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(object: I): QueryTotalSupplyResponse {
		const message = createBaseQueryTotalSupplyResponse();
		message.supply = object.supply?.map((e) => Coin.fromPartial(e)) || [];
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQuerySupplyOfRequest(): QuerySupplyOfRequest {
	return { denom: "" };
}

export const QuerySupplyOfRequest: MessageFns<QuerySupplyOfRequest, "cosmos.bank.v1beta1.QuerySupplyOfRequest"> = {
	$type: "cosmos.bank.v1beta1.QuerySupplyOfRequest" as const,

	encode(message: QuerySupplyOfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.denom !== "") {
			writer.uint32(10).string(message.denom);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyOfRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQuerySupplyOfRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.denom = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QuerySupplyOfRequest {
		return { denom: isSet(object.denom) ? globalThis.String(object.denom) : "" };
	},

	toJSON(message: QuerySupplyOfRequest): unknown {
		const obj: any = {};
		if (message.denom !== "") {
			obj.denom = message.denom;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QuerySupplyOfRequest>, I>>(base?: I): QuerySupplyOfRequest {
		return QuerySupplyOfRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QuerySupplyOfRequest>, I>>(object: I): QuerySupplyOfRequest {
		const message = createBaseQuerySupplyOfRequest();
		message.denom = object.denom ?? "";
		return message;
	}
};

function createBaseQuerySupplyOfResponse(): QuerySupplyOfResponse {
	return { amount: undefined };
}

export const QuerySupplyOfResponse: MessageFns<QuerySupplyOfResponse, "cosmos.bank.v1beta1.QuerySupplyOfResponse"> = {
	$type: "cosmos.bank.v1beta1.QuerySupplyOfResponse" as const,

	encode(message: QuerySupplyOfResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.amount !== undefined) {
			Coin.encode(message.amount, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyOfResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQuerySupplyOfResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.amount = Coin.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QuerySupplyOfResponse {
		return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
	},

	toJSON(message: QuerySupplyOfResponse): unknown {
		const obj: any = {};
		if (message.amount !== undefined) {
			obj.amount = Coin.toJSON(message.amount);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QuerySupplyOfResponse>, I>>(base?: I): QuerySupplyOfResponse {
		return QuerySupplyOfResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QuerySupplyOfResponse>, I>>(object: I): QuerySupplyOfResponse {
		const message = createBaseQuerySupplyOfResponse();
		message.amount = object.amount !== undefined && object.amount !== null ? Coin.fromPartial(object.amount) : undefined;
		return message;
	}
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
	return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest, "cosmos.bank.v1beta1.QueryParamsRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryParamsRequest" as const,

	encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryParamsRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): QueryParamsRequest {
		return {};
	},

	toJSON(_: QueryParamsRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
		return QueryParamsRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
		const message = createBaseQueryParamsRequest();
		return message;
	}
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
	return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse, "cosmos.bank.v1beta1.QueryParamsResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryParamsResponse" as const,

	encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.params !== undefined) {
			Params.encode(message.params, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryParamsResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.params = Params.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryParamsResponse {
		return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
	},

	toJSON(message: QueryParamsResponse): unknown {
		const obj: any = {};
		if (message.params !== undefined) {
			obj.params = Params.toJSON(message.params);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
		return QueryParamsResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
		const message = createBaseQueryParamsResponse();
		message.params = object.params !== undefined && object.params !== null ? Params.fromPartial(object.params) : undefined;
		return message;
	}
};

function createBaseQueryDenomsMetadataRequest(): QueryDenomsMetadataRequest {
	return { pagination: undefined };
}

export const QueryDenomsMetadataRequest: MessageFns<QueryDenomsMetadataRequest, "cosmos.bank.v1beta1.QueryDenomsMetadataRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryDenomsMetadataRequest" as const,

	encode(message: QueryDenomsMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.pagination !== undefined) {
			PageRequest.encode(message.pagination, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomsMetadataRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryDenomsMetadataRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.pagination = PageRequest.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryDenomsMetadataRequest {
		return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
	},

	toJSON(message: QueryDenomsMetadataRequest): unknown {
		const obj: any = {};
		if (message.pagination !== undefined) {
			obj.pagination = PageRequest.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryDenomsMetadataRequest>, I>>(base?: I): QueryDenomsMetadataRequest {
		return QueryDenomsMetadataRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryDenomsMetadataRequest>, I>>(object: I): QueryDenomsMetadataRequest {
		const message = createBaseQueryDenomsMetadataRequest();
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQueryDenomsMetadataResponse(): QueryDenomsMetadataResponse {
	return { metadatas: [], pagination: undefined };
}

export const QueryDenomsMetadataResponse: MessageFns<QueryDenomsMetadataResponse, "cosmos.bank.v1beta1.QueryDenomsMetadataResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryDenomsMetadataResponse" as const,

	encode(message: QueryDenomsMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		for (const v of message.metadatas) {
			Metadata.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.pagination !== undefined) {
			PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomsMetadataResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryDenomsMetadataResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.metadatas.push(Metadata.decode(reader, reader.uint32()));
					continue;
				case 2:
					if (tag !== 18) {
						break;
					}

					message.pagination = PageResponse.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryDenomsMetadataResponse {
		return {
			metadatas: globalThis.Array.isArray(object?.metadatas) ? object.metadatas.map((e: any) => Metadata.fromJSON(e)) : [],
			pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined
		};
	},

	toJSON(message: QueryDenomsMetadataResponse): unknown {
		const obj: any = {};
		if (message.metadatas?.length) {
			obj.metadatas = message.metadatas.map((e) => Metadata.toJSON(e));
		}
		if (message.pagination !== undefined) {
			obj.pagination = PageResponse.toJSON(message.pagination);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryDenomsMetadataResponse>, I>>(base?: I): QueryDenomsMetadataResponse {
		return QueryDenomsMetadataResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryDenomsMetadataResponse>, I>>(object: I): QueryDenomsMetadataResponse {
		const message = createBaseQueryDenomsMetadataResponse();
		message.metadatas = object.metadatas?.map((e) => Metadata.fromPartial(e)) || [];
		message.pagination = object.pagination !== undefined && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : undefined;
		return message;
	}
};

function createBaseQueryDenomMetadataRequest(): QueryDenomMetadataRequest {
	return { denom: "" };
}

export const QueryDenomMetadataRequest: MessageFns<QueryDenomMetadataRequest, "cosmos.bank.v1beta1.QueryDenomMetadataRequest"> = {
	$type: "cosmos.bank.v1beta1.QueryDenomMetadataRequest" as const,

	encode(message: QueryDenomMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.denom !== "") {
			writer.uint32(10).string(message.denom);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomMetadataRequest {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryDenomMetadataRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.denom = reader.string();
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryDenomMetadataRequest {
		return { denom: isSet(object.denom) ? globalThis.String(object.denom) : "" };
	},

	toJSON(message: QueryDenomMetadataRequest): unknown {
		const obj: any = {};
		if (message.denom !== "") {
			obj.denom = message.denom;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryDenomMetadataRequest>, I>>(base?: I): QueryDenomMetadataRequest {
		return QueryDenomMetadataRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryDenomMetadataRequest>, I>>(object: I): QueryDenomMetadataRequest {
		const message = createBaseQueryDenomMetadataRequest();
		message.denom = object.denom ?? "";
		return message;
	}
};

function createBaseQueryDenomMetadataResponse(): QueryDenomMetadataResponse {
	return { metadata: undefined };
}

export const QueryDenomMetadataResponse: MessageFns<QueryDenomMetadataResponse, "cosmos.bank.v1beta1.QueryDenomMetadataResponse"> = {
	$type: "cosmos.bank.v1beta1.QueryDenomMetadataResponse" as const,

	encode(message: QueryDenomMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomMetadataResponse {
		const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
		let end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseQueryDenomMetadataResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1:
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): QueryDenomMetadataResponse {
		return { metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined };
	},

	toJSON(message: QueryDenomMetadataResponse): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<QueryDenomMetadataResponse>, I>>(base?: I): QueryDenomMetadataResponse {
		return QueryDenomMetadataResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<QueryDenomMetadataResponse>, I>>(object: I): QueryDenomMetadataResponse {
		const message = createBaseQueryDenomMetadataResponse();
		message.metadata = object.metadata !== undefined && object.metadata !== null ? Metadata.fromPartial(object.metadata) : undefined;
		return message;
	}
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
	readonly $type: V;
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
